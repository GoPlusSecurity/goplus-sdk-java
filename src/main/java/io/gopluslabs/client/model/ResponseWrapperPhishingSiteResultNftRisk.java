/*
 * GoPlus Security API Document
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.gopluslabs.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.gopluslabs.client.model.ResponseWrapperPhishingSiteResultNftRiskPrivilegedBurn;
import io.gopluslabs.client.model.ResponseWrapperPhishingSiteResultNftRiskPrivilegedMinting;
import io.gopluslabs.client.model.ResponseWrapperPhishingSiteResultNftRiskSelfDestruct;
import io.gopluslabs.client.model.ResponseWrapperPhishingSiteResultNftRiskTransferWithoutApproval;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * nft check risk
 */
@Schema(description = "nft check risk")


public class ResponseWrapperPhishingSiteResultNftRisk {
  @SerializedName("nft_open_source")
  private Integer nftOpenSource = null;

  @SerializedName("privileged_minting")
  private ResponseWrapperPhishingSiteResultNftRiskPrivilegedMinting privilegedMinting = null;

  @SerializedName("oversupply_minting")
  private Integer oversupplyMinting = null;

  @SerializedName("nft_proxy")
  private Integer nftProxy = null;

  @SerializedName("restricted_approval")
  private Integer restrictedApproval = null;

  @SerializedName("transfer_without_approval")
  private ResponseWrapperPhishingSiteResultNftRiskTransferWithoutApproval transferWithoutApproval = null;

  @SerializedName("privileged_burn")
  private ResponseWrapperPhishingSiteResultNftRiskPrivilegedBurn privilegedBurn = null;

  @SerializedName("self_destruct")
  private ResponseWrapperPhishingSiteResultNftRiskSelfDestruct selfDestruct = null;

  public ResponseWrapperPhishingSiteResultNftRisk nftOpenSource(Integer nftOpenSource) {
    this.nftOpenSource = nftOpenSource;
    return this;
  }

   /**
   * It describes whether this contract is open source.  \&quot;1\&quot; means true;  \&quot;0\&quot; means false.(Notice:Un-open-sourced contracts may hide various unknown mechanisms and are extremely risky. When the contract is not open source, we will not be able to detect other risk items.)
   * @return nftOpenSource
  **/
  @Schema(description = "It describes whether this contract is open source.  \"1\" means true;  \"0\" means false.(Notice:Un-open-sourced contracts may hide various unknown mechanisms and are extremely risky. When the contract is not open source, we will not be able to detect other risk items.)")
  public Integer getNftOpenSource() {
    return nftOpenSource;
  }

  public void setNftOpenSource(Integer nftOpenSource) {
    this.nftOpenSource = nftOpenSource;
  }

  public ResponseWrapperPhishingSiteResultNftRisk privilegedMinting(ResponseWrapperPhishingSiteResultNftRiskPrivilegedMinting privilegedMinting) {
    this.privilegedMinting = privilegedMinting;
    return this;
  }

   /**
   * Get privilegedMinting
   * @return privilegedMinting
  **/
  @Schema(description = "")
  public ResponseWrapperPhishingSiteResultNftRiskPrivilegedMinting getPrivilegedMinting() {
    return privilegedMinting;
  }

  public void setPrivilegedMinting(ResponseWrapperPhishingSiteResultNftRiskPrivilegedMinting privilegedMinting) {
    this.privilegedMinting = privilegedMinting;
  }

  public ResponseWrapperPhishingSiteResultNftRisk oversupplyMinting(Integer oversupplyMinting) {
    this.oversupplyMinting = oversupplyMinting;
    return this;
  }

   /**
   * It describes whether this NFT owner can bypass the maximum amount of minting specified in the contract, and continue to mint NFTs beyond this limit.  \&quot;1\&quot; means true;  \&quot;0\&quot; means false;  \&quot;Null\&quot; means unknown.(Notice:Oversupply minting refers to the existence of a special mint method in the NFT contract - the owner can bypass the maximum amount of minting specified in the contract, and continue to mint NFTs beyond this limit.)
   * @return oversupplyMinting
  **/
  @Schema(description = "It describes whether this NFT owner can bypass the maximum amount of minting specified in the contract, and continue to mint NFTs beyond this limit.  \"1\" means true;  \"0\" means false;  \"Null\" means unknown.(Notice:Oversupply minting refers to the existence of a special mint method in the NFT contract - the owner can bypass the maximum amount of minting specified in the contract, and continue to mint NFTs beyond this limit.)")
  public Integer getOversupplyMinting() {
    return oversupplyMinting;
  }

  public void setOversupplyMinting(Integer oversupplyMinting) {
    this.oversupplyMinting = oversupplyMinting;
  }

  public ResponseWrapperPhishingSiteResultNftRisk nftProxy(Integer nftProxy) {
    this.nftProxy = nftProxy;
    return this;
  }

   /**
   * It describes whether this NFT contract has a proxy contract.  \&quot;1\&quot; means true;  \&quot;0\&quot; means false;  \&quot;Null\&quot; means unknown.(Notice:(1) When \&quot;is_open_source\&quot;:\&quot;0\&quot;, it will return \&quot;null\&quot;. (2) Most Proxy contracts are accompanied by modifiable implementation contracts, and implementation contracts may contain significant potential risk.)
   * @return nftProxy
  **/
  @Schema(description = "It describes whether this NFT contract has a proxy contract.  \"1\" means true;  \"0\" means false;  \"Null\" means unknown.(Notice:(1) When \"is_open_source\":\"0\", it will return \"null\". (2) Most Proxy contracts are accompanied by modifiable implementation contracts, and implementation contracts may contain significant potential risk.)")
  public Integer getNftProxy() {
    return nftProxy;
  }

  public void setNftProxy(Integer nftProxy) {
    this.nftProxy = nftProxy;
  }

  public ResponseWrapperPhishingSiteResultNftRisk restrictedApproval(Integer restrictedApproval) {
    this.restrictedApproval = restrictedApproval;
    return this;
  }

   /**
   * It describes whether the NFT contract can restrict the approval, resulting in NFT can not be traded on the NFT DEX. \&quot;1\&quot; means true;  \&quot;0\&quot; means false;  \&quot;Null\&quot; means unknown.(Notice:If this risk exists, it means that users will not be able to trade the NFT on the exchange and only privileged users in the whitelist will be able to trade normally.)
   * @return restrictedApproval
  **/
  @Schema(description = "It describes whether the NFT contract can restrict the approval, resulting in NFT can not be traded on the NFT DEX. \"1\" means true;  \"0\" means false;  \"Null\" means unknown.(Notice:If this risk exists, it means that users will not be able to trade the NFT on the exchange and only privileged users in the whitelist will be able to trade normally.)")
  public Integer getRestrictedApproval() {
    return restrictedApproval;
  }

  public void setRestrictedApproval(Integer restrictedApproval) {
    this.restrictedApproval = restrictedApproval;
  }

  public ResponseWrapperPhishingSiteResultNftRisk transferWithoutApproval(ResponseWrapperPhishingSiteResultNftRiskTransferWithoutApproval transferWithoutApproval) {
    this.transferWithoutApproval = transferWithoutApproval;
    return this;
  }

   /**
   * Get transferWithoutApproval
   * @return transferWithoutApproval
  **/
  @Schema(description = "")
  public ResponseWrapperPhishingSiteResultNftRiskTransferWithoutApproval getTransferWithoutApproval() {
    return transferWithoutApproval;
  }

  public void setTransferWithoutApproval(ResponseWrapperPhishingSiteResultNftRiskTransferWithoutApproval transferWithoutApproval) {
    this.transferWithoutApproval = transferWithoutApproval;
  }

  public ResponseWrapperPhishingSiteResultNftRisk privilegedBurn(ResponseWrapperPhishingSiteResultNftRiskPrivilegedBurn privilegedBurn) {
    this.privilegedBurn = privilegedBurn;
    return this;
  }

   /**
   * Get privilegedBurn
   * @return privilegedBurn
  **/
  @Schema(description = "")
  public ResponseWrapperPhishingSiteResultNftRiskPrivilegedBurn getPrivilegedBurn() {
    return privilegedBurn;
  }

  public void setPrivilegedBurn(ResponseWrapperPhishingSiteResultNftRiskPrivilegedBurn privilegedBurn) {
    this.privilegedBurn = privilegedBurn;
  }

  public ResponseWrapperPhishingSiteResultNftRisk selfDestruct(ResponseWrapperPhishingSiteResultNftRiskSelfDestruct selfDestruct) {
    this.selfDestruct = selfDestruct;
    return this;
  }

   /**
   * Get selfDestruct
   * @return selfDestruct
  **/
  @Schema(description = "")
  public ResponseWrapperPhishingSiteResultNftRiskSelfDestruct getSelfDestruct() {
    return selfDestruct;
  }

  public void setSelfDestruct(ResponseWrapperPhishingSiteResultNftRiskSelfDestruct selfDestruct) {
    this.selfDestruct = selfDestruct;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ResponseWrapperPhishingSiteResultNftRisk responseWrapperPhishingSiteResultNftRisk = (ResponseWrapperPhishingSiteResultNftRisk) o;
    return Objects.equals(this.nftOpenSource, responseWrapperPhishingSiteResultNftRisk.nftOpenSource) &&
        Objects.equals(this.privilegedMinting, responseWrapperPhishingSiteResultNftRisk.privilegedMinting) &&
        Objects.equals(this.oversupplyMinting, responseWrapperPhishingSiteResultNftRisk.oversupplyMinting) &&
        Objects.equals(this.nftProxy, responseWrapperPhishingSiteResultNftRisk.nftProxy) &&
        Objects.equals(this.restrictedApproval, responseWrapperPhishingSiteResultNftRisk.restrictedApproval) &&
        Objects.equals(this.transferWithoutApproval, responseWrapperPhishingSiteResultNftRisk.transferWithoutApproval) &&
        Objects.equals(this.privilegedBurn, responseWrapperPhishingSiteResultNftRisk.privilegedBurn) &&
        Objects.equals(this.selfDestruct, responseWrapperPhishingSiteResultNftRisk.selfDestruct);
  }

  @Override
  public int hashCode() {
    return Objects.hash(nftOpenSource, privilegedMinting, oversupplyMinting, nftProxy, restrictedApproval, transferWithoutApproval, privilegedBurn, selfDestruct);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ResponseWrapperPhishingSiteResultNftRisk {\n");
    
    sb.append("    nftOpenSource: ").append(toIndentedString(nftOpenSource)).append("\n");
    sb.append("    privilegedMinting: ").append(toIndentedString(privilegedMinting)).append("\n");
    sb.append("    oversupplyMinting: ").append(toIndentedString(oversupplyMinting)).append("\n");
    sb.append("    nftProxy: ").append(toIndentedString(nftProxy)).append("\n");
    sb.append("    restrictedApproval: ").append(toIndentedString(restrictedApproval)).append("\n");
    sb.append("    transferWithoutApproval: ").append(toIndentedString(transferWithoutApproval)).append("\n");
    sb.append("    privilegedBurn: ").append(toIndentedString(privilegedBurn)).append("\n");
    sb.append("    selfDestruct: ").append(toIndentedString(selfDestruct)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
